# Knowledge Base Codebase Analysis

> Comprehensive analysis of the current "Documents" feature in Content Studio, in preparation for transforming it into a Knowledge Base feature.

## Table of Contents

1. [Current Data Model](#1-current-data-model)
2. [API Layer](#2-api-layer)
3. [Domain Logic (Use Cases)](#3-domain-logic-use-cases)
4. [Frontend Architecture](#4-frontend-architecture)
5. [File Handling & Storage](#5-file-handling--storage)
6. [Cross-Feature Relationships](#6-cross-feature-relationships)
7. [Queue / Background Processing](#7-queue--background-processing)
8. [AI Integration](#8-ai-integration)
9. [Key Files Index](#9-key-files-index)
10. [Technical Debt & Limitations](#10-technical-debt--limitations)
11. [What Can Be Extended vs. What Must Change](#11-what-can-be-extended-vs-what-must-change)

---

## 1. Current Data Model

### `document` Table (`packages/db/src/schemas/documents.ts`)

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | `varchar(20)` | PK, branded `DocumentId` | Pattern: `doc_[base32]{16}` |
| `title` | `text` | NOT NULL | User-facing title |
| `contentKey` | `text` | NOT NULL | Storage key (S3/filesystem path) for the raw file |
| `mimeType` | `text` | NOT NULL | MIME type of stored content |
| `wordCount` | `integer` | NOT NULL, default 0 | Pre-calculated word count |
| `source` | `document_source` enum | NOT NULL, default 'manual' | How the doc was created |
| `originalFileName` | `text` | nullable | Original upload filename |
| `originalFileSize` | `integer` | nullable | Original file size in bytes |
| `metadata` | `jsonb` | nullable | Arbitrary key-value metadata (page counts, warnings, etc.) |
| `createdBy` | `text` | NOT NULL, FK -> user.id (CASCADE) | Owner user ID |
| `createdAt` | `timestamp with tz` | NOT NULL, default now() | Creation timestamp |
| `updatedAt` | `timestamp with tz` | NOT NULL, default now() | Last update timestamp |

**Indexes:**
- `document_createdBy_idx` on `createdBy`
- `document_createdAt_idx` on `createdAt`

**Enums:**
```
document_source: 'manual' | 'upload_txt' | 'upload_pdf' | 'upload_docx' | 'upload_pptx'
```

**Branded ID:**
- Pattern: `doc_[0-9a-hjkmnp-tv-z]{16}` (base32, Crockford-style)
- Generated by: `generateDocumentId()` in `packages/db/src/schemas/brands.ts`

### No Junction/Relationship Tables

Documents are **not** connected to podcasts via a junction table. Instead:
- Podcasts store `sourceDocumentIds: varchar(20)[]` as a Postgres array column directly on the `podcast` table.
- Infographics store `sourceDocumentIds: jsonb` (string array) directly on the `infographic` table.
- There is **no foreign key constraint** between podcast/infographic and document -- just IDs stored in arrays.

### Serialization

Three serializer flavors exist in `packages/db/src/schemas/documents.ts`:
- `serializeDocumentEffect` -- Effect-based, traced (for router handlers)
- `serializeDocumentsEffect` -- Batch Effect-based, traced
- `serializeDocument` -- Sync (used by podcast serializer to inline documents)

**Output Schema (`DocumentOutputSchema`):**
```typescript
{
  id: DocumentIdSchema,
  title: string,
  contentKey: string,
  mimeType: string,
  wordCount: number,
  source: DocumentSourceSchema,
  originalFileName: string | null,
  originalFileSize: number | null,
  metadata: Record<string, unknown> | null,
  createdBy: string,
  createdAt: string,  // ISO 8601
  updatedAt: string,  // ISO 8601
}
```

---

## 2. API Layer

### Contract (`packages/api/src/contracts/documents.ts`)

All endpoints are prefixed with `/documents` and tagged `document`.

| Method | Path | Name | Description | Input | Output |
|--------|------|------|-------------|-------|--------|
| GET | `/` | `list` | List user's documents | `{ limit?: number, offset?: number }` | `DocumentOutputSchema[]` |
| GET | `/{id}` | `get` | Get single document | `{ id: DocumentId }` | `DocumentOutputSchema` |
| GET | `/{id}/content` | `getContent` | Get parsed text content | `{ id: DocumentId }` | `{ content: string }` |
| POST | `/` | `create` | Create from text | `{ title, content, metadata? }` | `DocumentOutputSchema` |
| POST | `/upload` | `upload` | Upload file (base64) | `{ fileName, mimeType, data, title?, metadata? }` | `DocumentOutputSchema` |
| PATCH | `/{id}` | `update` | Update metadata/content | `{ id, title?, content?, metadata? }` | `DocumentOutputSchema` |
| DELETE | `/{id}` | `delete` | Delete permanently | `{ id: DocumentId }` | `{}` |

**Contract-Level Errors:**
- `DOCUMENT_NOT_FOUND` (404) -- with `{ documentId }`
- `DOCUMENT_TOO_LARGE` (413) -- with `{ fileName, fileSize, maxSize }`
- `UNSUPPORTED_FORMAT` (415) -- with `{ fileName, mimeType, supportedFormats }`
- `DOCUMENT_PARSE_ERROR` (422) -- with `{ fileName }`

**File Upload Details:**
- Files are sent as **base64-encoded strings** in the JSON body (`data` field)
- Max file size: 10MB
- Supported types: TXT, PDF, DOCX, PPTX
- The router handler decodes base64 to Buffer before passing to use case

### Router (`packages/api/src/server/router/document.ts`)

- All routes use `protectedProcedure` (auth required)
- All routes use `handleEffectWithProtocol` for Effect-to-oRPC bridging
- Activity logging: `create` and `upload` log "created document"; `delete` logs "deleted document"
- `update` calls `tapSyncTitle` to sync title changes in activity log
- All handlers add OpenTelemetry span attributes

### Contract Registration (`packages/api/src/contracts/index.ts`)

Documents are registered at `appContract.router.documents` alongside:
- `admin` (activity), `events` (SSE), `infographics`, `podcasts`, `voiceovers`, `voices`

---

## 3. Domain Logic (Use Cases)

All use cases are in `packages/media/src/document/use-cases/`.

### `createDocument` (create-document.ts)
- **Input:** `{ title, content, metadata?, userId? }`
- **Flow:** Get current user -> store content as `documents/{uuid}.txt` in storage -> insert DB row with word count -> rollback storage on DB failure
- **Auth:** Uses `getCurrentUser` (accepts optional `userId` override for admin)
- **Storage key pattern:** `documents/{uuid}.txt`

### `uploadDocument` (upload-document.ts)
- **Input:** `{ fileName, mimeType, data: Buffer, title?, metadata? }`
- **Flow:** Get MIME type -> parse file (validate size/format, extract text) -> upload raw file to storage -> insert DB row -> rollback storage on DB failure
- **Parsing:** Delegates to `parseUploadedFile()` which handles TXT/PDF/DOCX/PPTX
- **Storage key pattern:** `documents/{uuid}.{ext}` (preserves original extension)
- **Title inference:** Uses filename (without extension, hyphens/underscores to spaces) if no title provided

### `getDocument` (get-document.ts)
- **Input:** `{ id }`
- **Flow:** Find by ID -> check ownership -> return
- **Auth:** `requireOwnership(doc.createdBy)`

### `getDocumentContent` (get-document-content.ts)
- **Input:** `{ id }`
- **Flow:** Find by ID -> check ownership -> download from storage -> parse if not text/plain -> return content string
- **Auth:** `requireOwnership(doc.createdBy)`
- **Note:** For non-text files, re-parses on every read (no content caching)

### `listDocuments` (list-documents.ts)
- **Input:** `{ userId?, limit?, offset? }`
- **Flow:** Get current user -> determine filter (admin sees all or filtered, non-admin sees own) -> parallel fetch (list + count) -> return with pagination metadata
- **Auth:** Implicit via `getCurrentUser` and role check

### `updateDocument` (update-document.ts)
- **Input:** `{ id, title?, content?, metadata? }`
- **Flow:** Find existing -> check ownership -> if content changed: delete old storage key, upload new -> update DB row
- **Auth:** `requireOwnership(existing.createdBy)`
- **Note:** Content updates delete old file and create new one (no in-place update)

### `deleteDocument` (delete-document.ts)
- **Input:** `{ id }`
- **Flow:** Find existing -> check ownership -> delete storage file (ignore errors) -> delete DB row
- **Auth:** `requireOwnership(existing.createdBy)`
- **Note:** Storage deletion is fire-and-forget (`Effect.ignore`)

### Repository (`packages/media/src/document/repos/document-repo.ts`)

Uses the `Context.Tag` / `Layer` pattern:
- **Tag:** `DocumentRepo` (`@repo/media/DocumentRepo`)
- **Layer:** `DocumentRepoLive` (depends on `Db`)
- **Methods:** `insert`, `findById`, `list`, `update`, `delete`, `count`
- **Ordering:** `list` returns by `createdAt DESC`
- **Error:** `findById` and `update` fail with `DocumentNotFound` if not found

### File Parsers (`packages/media/src/document/parsers.ts`)

| Format | Library | Extracted Data |
|--------|---------|---------------|
| TXT | Built-in `Buffer.toString` | Plain text content |
| PDF | `pdf-parse` (dynamic import) | Text + page count + info metadata |
| DOCX | `mammoth` (dynamic import) | Raw text + parsing warnings |
| PPTX | `pptx-parser` (require) | Text from all slides, with slide markers |

**Validation:**
- `validateFileSize()` -- max 10MB
- `validateMimeType()` -- checks against `SUPPORTED_MIME_TYPES` map

### Error Types (`packages/media/src/errors.ts` + `document/errors.ts`)

| Error Class | Tag | HTTP Status | Log Level |
|-------------|-----|-------------|-----------|
| `DocumentNotFound` | `DocumentNotFound` | 404 | silent |
| `DocumentError` | `DocumentError` | 500 | error-with-stack |
| `DocumentTooLargeError` | `DocumentTooLargeError` | 413 | silent |
| `UnsupportedDocumentFormat` | `UnsupportedDocumentFormat` | 415 | silent |
| `DocumentParseError` | `DocumentParseError` | 422 | warn |
| `DocumentContentNotFound` | `DocumentContentNotFound` | 404 | warn |

All errors use `Schema.TaggedError` with HTTP protocol properties.

---

## 4. Frontend Architecture

### Routing (`apps/web/src/routes/_protected/documents/`)

| Route | File | Component | Loader |
|-------|------|-----------|--------|
| `/documents` | `index.tsx` | `DocumentListContainer` | `ensureQueryData(documents.list)` |
| `/documents/$documentId` | `$documentId.tsx` | `DocumentDetailContainer` | `ensureQueryData(documents.get)` + `ensureQueryData(documents.getContent)` |

Both routes set `document.title` via `useEffect`.

### Feature Components (`apps/web/src/features/documents/`)

#### List View
- **Container:** `DocumentListContainer` -- manages search state, delete confirmation, bulk selection, bulk delete
- **Presenter:** `DocumentList` -- table layout with columns: Checkbox, Title (with icon + link), Type badge, Word count, Size, Created date, Delete button
- **Row Component:** `DocumentRow` (memoized) -- individual table row with hover-visible delete button
- **Empty States:** Two variants -- "No documents yet" and "No documents found" (search)

**List Features:**
- Client-side text search (filters by title, case-insensitive)
- `useTransition` for non-blocking search updates
- Bulk selection with select-all/indeterminate checkbox
- Bulk delete with `BulkActionBar` component
- Single delete with optimistic removal + confirmation dialog
- Upload dialog trigger

#### Detail View
- **Container:** `DocumentDetailContainer` -- fetches document + content, manages edit/delete state
- **Presenter:** `DocumentDetail` -- workbench layout with header, search bar, metadata bar, content reader, action bar

**Detail Features:**
- In-document text search (Cmd+F override) with match highlighting, navigation (next/prev), and scroll-into-view
- Inline title editing with save/discard action bar
- Keyboard shortcuts: Cmd+S (save), Cmd+F (search)
- Navigation blocking when unsaved changes (`useNavigationBlock`)
- Delete with confirmation dialog
- Back navigation to `/documents`
- Content rendered as paragraphs split by `\n`

#### Upload Dialog
- **Component:** `UploadDocumentDialog`
- Drag-and-drop + click-to-browse file selection
- Client-side validation: file type + 10MB size limit
- Auto-fills title from filename
- Base64 encoding before upload
- Toast notifications for success/error

#### Supporting Components
- `DocumentIcon` -- SVG icon colored by source type (PDF=red, DOCX=blue, PPTX=amber, TXT=blue, default=muted)
- `DocumentItem` -- Card-style item (used for... appears unused in current document list, which uses table rows)

### Feature Hooks (`apps/web/src/features/documents/hooks/`)

| Hook | Purpose |
|------|---------|
| `useDocumentList` | Fetch document list with options (uses `useQuery`) |
| `useSuspenseDocumentList` | Suspense variant of list fetch |
| `useDocumentsOrdered` | Sorted document list with `select` transform |
| `getDocumentListQueryKey` | Query key factory for cache operations |
| `useDocument` | Fetch single document (suspense) |
| `useDocumentContent` | Fetch document content (suspense) |
| `useDocumentActions` | Title editing, save/delete mutations, discard |
| `useDocumentSearch` | In-document text search with match navigation |
| `useOptimisticDeleteDocument` | Optimistic list removal on delete |
| `useOptimisticUpload` | Upload mutation with query invalidation |

### Shared Document Components (`apps/web/src/shared/components/document-manager/`)

These are **reused by podcast workbench** (and potentially infographic) to manage document attachments:

| Component | Purpose |
|-----------|---------|
| `DocumentManager` | Container: dialog + list for managing attached documents |
| `AddDocumentDialog` | Two-tab dialog: "Select Existing" / "Upload New" |
| `ExistingDocumentPicker` | Searchable checklist of existing documents |
| `DocumentUploader` | Drag-and-drop file upload with title input |
| `DocumentList` (shared) | Compact list of attached docs with remove buttons |

### Shared Hooks

| Hook | Location | Purpose |
|------|----------|---------|
| `useDocumentSelection` | `shared/hooks/` | Manages selected document IDs for multi-document workflows (podcast creation, etc.) |

### Podcast-Specific Document Components (`apps/web/src/features/podcasts/`)

| Component | Purpose |
|-----------|---------|
| `StepDocuments` | Podcast setup Step 1: select/upload source documents |
| `DocumentManager` (podcast) | Podcast workbench: manage attached documents with min-1 enforcement |
| `DocumentContentViewer` | Expandable document content preview in prompt viewer |

---

## 5. File Handling & Storage

### Storage Service (`packages/storage/`)

**Interface (`StorageService`):**
- `upload(key, data, contentType)` -> returns URL
- `download(key)` -> returns Buffer
- `delete(key)` -> void
- `getUrl(key)` -> returns URL
- `exists(key)` -> boolean

**Providers:**
- `FilesystemStorageLive` -- local filesystem (dev mode), stores at `{basePath}/{key}`
- `S3StorageLive` -- S3-compatible (production), stores at `{bucket}/{key}`

### Document Storage Patterns

| Operation | Key Pattern | Content Type |
|-----------|-------------|--------------|
| Create (text) | `documents/{uuid}.txt` | `text/plain` |
| Upload (file) | `documents/{uuid}.{original-ext}` | Original MIME type |
| Update (text) | `documents/{new-uuid}.txt` | `text/plain` |

**Key observations:**
- Raw uploaded files are stored (not just extracted text)
- Content is re-parsed on read for non-text files (`getDocumentContent`)
- No content caching layer -- every `getContent` call hits storage + parser
- Old files are deleted when content is updated (no versioning)
- Storage deletion on document delete is fire-and-forget

---

## 6. Cross-Feature Relationships

### Documents -> Podcasts

**Storage:** `podcast.sourceDocumentIds` is a `varchar(20)[]` Postgres array.

**How podcasts use documents:**
1. **Creation:** Podcast setup Step 1 lets users select/upload documents. Selected IDs are stored in `sourceDocumentIds`.
2. **Script generation:** The AI reads document content to generate podcast scripts. `GenerationContext` includes `sourceDocuments` with `{ id, title, contentHash? }`.
3. **Workbench:** Podcast workbench shows attached documents via `DocumentManager`, allows add/remove.
4. **Prompt viewer:** `DocumentContentViewer` shows expandable document content in the prompt panel.
5. **Serialization:** `PodcastFullOutputSchema` includes a `documents: DocumentOutputSchema[]` array. The podcast repo fetches full document objects and inlines them.

**No cascade deletion:** Deleting a document does NOT remove it from any podcast's `sourceDocumentIds`. The podcast will have dangling references (IDs pointing to deleted documents).

### Documents -> Infographics

**Storage:** `infographic.sourceDocumentIds` is a `jsonb` column (string array).

**Similar pattern:** Infographics reference documents by ID in a JSON array. Used as source material for AI-generated graphics.

### Documents -> Activity Log

**Integration:** Document create/update/delete operations are logged via `tapLogActivity` and `tapSyncTitle` in the router. Entity type is `'document'` in the activity log.

### Documents -> Media Types

In `packages/db/src/schemas/media-types.ts`, `'document'` is one of the `ContentType` enum values. The `MEDIA_TYPE_CONFIG` defines:
- `document.acceptsInputFrom`: `['podcast', 'video', 'article']`
- `document.canBeInputFor`: not explicitly listed (but other types list document)
- Podcasts accept input from `['document']`
- Videos accept from `['document', 'podcast', 'graphic']`
- Articles accept from `['document', 'podcast']`
- Social accepts from `['document', 'podcast', 'video', 'article', 'graphic']`
- Graphics accept from `['document', 'podcast']`

**Documents are the foundational content type** -- nearly every other content type accepts documents as input.

---

## 7. Queue / Background Processing

**No document-specific queue jobs exist.** All document operations (create, upload, parse, delete) are synchronous within the request lifecycle.

This is notable because:
- Large PDF parsing happens inline during upload
- No background indexing, text extraction, or content processing
- No async document import workflows

---

## 8. AI Integration

**No direct AI integration exists in the document module.** There are no files in `packages/ai/src/` related to documents.

Documents serve as **passive source material** for other AI features:
- Podcast script generation reads document content
- Infographic generation reads document content
- Voiceovers don't directly reference documents (they have their own text)

There is no:
- AI-powered summarization of documents
- Auto-tagging or categorization
- Semantic search or embeddings
- Content extraction intelligence (beyond basic text parsing)

---

## 9. Key Files Index

### Database Layer
| File | Purpose |
|------|---------|
| `packages/db/src/schemas/documents.ts` | Table definition, enums, schemas, serializers |
| `packages/db/src/schemas/brands.ts` | `DocumentId` branded type + generator |
| `packages/db/src/schemas/podcasts.ts` | References `DocumentOutputSchema`, `sourceDocumentIds` |
| `packages/db/src/schemas/infographics.ts` | References `sourceDocumentIds` |
| `packages/db/src/schemas/media-types.ts` | `'document'` content type definition |
| `packages/db/src/schemas/activity-log.ts` | `'document'` entity type |

### API Layer
| File | Purpose |
|------|---------|
| `packages/api/src/contracts/documents.ts` | oRPC contract (7 endpoints) |
| `packages/api/src/contracts/index.ts` | Registers `documentContract` at `documents` |
| `packages/api/src/server/router/document.ts` | Route handlers (7 handlers) |

### Domain Logic
| File | Purpose |
|------|---------|
| `packages/media/src/document/repos/document-repo.ts` | Repository (CRUD + count) |
| `packages/media/src/document/use-cases/create-document.ts` | Create from text |
| `packages/media/src/document/use-cases/upload-document.ts` | Upload file |
| `packages/media/src/document/use-cases/get-document.ts` | Get by ID |
| `packages/media/src/document/use-cases/get-document-content.ts` | Get parsed content |
| `packages/media/src/document/use-cases/list-documents.ts` | List with pagination |
| `packages/media/src/document/use-cases/update-document.ts` | Update title/content |
| `packages/media/src/document/use-cases/delete-document.ts` | Delete with storage cleanup |
| `packages/media/src/document/parsers.ts` | File parsing (TXT, PDF, DOCX, PPTX) |
| `packages/media/src/document/errors.ts` | Re-exports from `../errors.ts` |
| `packages/media/src/errors.ts` | All document error classes |
| `packages/media/src/shared/text-utils.ts` | `calculateWordCount` utility |
| `packages/media/src/index.ts` | Package exports + `MediaLive` layer |

### Frontend - Feature
| File | Purpose |
|------|---------|
| `apps/web/src/routes/_protected/documents/index.tsx` | List route |
| `apps/web/src/routes/_protected/documents/$documentId.tsx` | Detail route |
| `apps/web/src/features/documents/components/document-list-container.tsx` | List container |
| `apps/web/src/features/documents/components/document-list.tsx` | List presenter (table) |
| `apps/web/src/features/documents/components/document-detail-container.tsx` | Detail container |
| `apps/web/src/features/documents/components/document-detail.tsx` | Detail presenter |
| `apps/web/src/features/documents/components/document-item.tsx` | Card-style item (appears unused) |
| `apps/web/src/features/documents/components/document-icon.tsx` | File type icon |
| `apps/web/src/features/documents/components/upload-document-dialog.tsx` | Upload dialog |

### Frontend - Hooks
| File | Purpose |
|------|---------|
| `apps/web/src/features/documents/hooks/use-document-list.ts` | List query + query key |
| `apps/web/src/features/documents/hooks/use-document.ts` | Single document + content queries |
| `apps/web/src/features/documents/hooks/use-document-actions.ts` | Edit/delete mutations |
| `apps/web/src/features/documents/hooks/use-document-search.ts` | In-document text search |
| `apps/web/src/features/documents/hooks/use-optimistic-delete-document.ts` | Optimistic list deletion |
| `apps/web/src/features/documents/hooks/use-optimistic-upload.ts` | Upload mutation |

### Frontend - Shared (Cross-Feature)
| File | Purpose |
|------|---------|
| `apps/web/src/shared/components/document-manager/document-manager.tsx` | Attach/detach documents |
| `apps/web/src/shared/components/document-manager/add-document-dialog.tsx` | Select existing + upload new |
| `apps/web/src/shared/components/document-manager/existing-document-picker.tsx` | Searchable doc picker |
| `apps/web/src/shared/components/document-manager/document-uploader.tsx` | Drag-and-drop uploader |
| `apps/web/src/shared/components/document-manager/document-list.tsx` | Compact attached doc list |
| `apps/web/src/shared/hooks/use-document-selection.ts` | Document selection state |

### Frontend - Podcast Integration
| File | Purpose |
|------|---------|
| `apps/web/src/features/podcasts/components/setup/steps/step-documents.tsx` | Podcast setup Step 1 |
| `apps/web/src/features/podcasts/components/workbench/document-manager.tsx` | Podcast workbench doc manager |
| `apps/web/src/features/podcasts/components/workbench/prompt-viewer/document-content-viewer.tsx` | Expandable content preview |
| `apps/web/src/features/podcasts/hooks/use-document-selection.ts` | Podcast-specific doc selection |

### Tests
| File | Purpose |
|------|---------|
| `packages/media/src/document/use-cases/__tests__/create-document.test.ts` | Create use case tests |
| `packages/media/src/document/use-cases/__tests__/get-document.test.ts` | Get use case tests |
| `packages/media/src/document/use-cases/__tests__/upload-document.test.ts` | Upload use case tests |
| `packages/media/src/document/use-cases/__tests__/delete-document.test.ts` | Delete use case tests |
| `packages/media/src/document/use-cases/__tests__/list-documents.test.ts` | List use case tests |
| `packages/media/src/document/use-cases/__tests__/update-document.test.ts` | Update use case tests |
| `packages/media/src/document/use-cases/__tests__/get-document-content.test.ts` | GetContent use case tests |
| `packages/api/src/server/router/__tests__/document.integration.test.ts` | Router integration tests |
| `apps/web/src/features/documents/__tests__/document-list.test.tsx` | Document list component tests |

---

## 10. Technical Debt & Limitations

### Data Model Issues

1. **No folder/collection/organization system.** Documents are a flat list per user. No way to group or categorize beyond the `metadata` JSONB field.

2. **No tags or labels.** Unlike podcasts (which have `tags: jsonb`), documents have no built-in tagging.

3. **No description field.** Documents only have a `title` -- no summary/description for context.

4. **No full-text search.** Search is client-side title matching only. No server-side search, no content indexing.

5. **Dangling references.** Deleting a document leaves orphaned IDs in `podcast.sourceDocumentIds` and `infographic.sourceDocumentIds`. No referential integrity.

6. **No content versioning.** Updating content deletes the old file and creates a new one. No history.

7. **`contentKey` exposed in API output.** The storage key is included in the serialized output but serves no client-side purpose (clients use the `getContent` endpoint).

### Performance Issues

8. **Content re-parsed on every read.** `getDocumentContent` downloads the raw file and re-parses PDF/DOCX/PPTX every time. No extracted-text caching.

9. **Base64 upload encoding.** Files are base64-encoded for upload, adding ~33% overhead. No multipart form upload support.

10. **No pagination in API response.** The `list` endpoint returns an array with no total count or pagination metadata in the response (though the use case calculates it).

11. **Client-side search only.** All filtering happens in the browser after fetching the full list.

### Code Quality Issues

12. **Duplicate upload logic.** Upload UI code is duplicated across:
    - `UploadDocumentDialog` (documents feature)
    - `DocumentUploader` (shared component)
    - `StepDocuments` (podcast setup)
    All three have independent file validation, base64 encoding, and drag-and-drop logic.

13. **`DocumentItem` card component appears unused.** The document list uses `DocumentRow` (table layout), but `DocumentItem` (card layout) exists and is defined but may not be rendered in the list page.

14. **`useDocumentsOrdered` does client-side sorting.** The API already returns documents sorted by `createdAt DESC`. The hook sorts again on the client with a `select` transform.

15. **`createDocument` accepts `userId` parameter.** This violates the CLAUDE.md rule "Never accept userId as a use case input parameter." The use case falls back to `getCurrentUser` but allows override.

### Missing Features

16. **No URL import.** Cannot import documents from URLs (web pages, Google Docs, etc.).

17. **No bulk upload.** Only one file at a time.

18. **No content editing.** The detail view is read-only for content; only title can be edited inline.

19. **No sharing or collaboration.** Documents are strictly per-user.

20. **No favorites or pinning.** No way to mark frequently-used documents.

---

## 11. What Can Be Extended vs. What Must Change

### Can Be Extended (Additive)

| Area | Extension | Effort |
|------|-----------|--------|
| **DB schema** | Add columns: `description`, `tags`, `folderId`, `status`, `processedContentKey` | Small (migration) |
| **DB schema** | Add new tables: `folder`, `document_tag` | Small (new schema file) |
| **DB schema** | Add new `document_source` enum values (e.g., `'url_import'`, `'ai_generated'`) | Small (migration) |
| **API contract** | Add new endpoints: `search`, `bulkUpload`, `importUrl`, `move`, `getTags` | Medium |
| **API contract** | Add query params to `list`: `folderId`, `tags`, `search`, `sortBy` | Small |
| **Repository** | Add methods: `findByTags`, `search`, `bulkInsert`, `moveToFolder` | Medium |
| **Use cases** | Add new: `importFromUrl`, `summarizeDocument`, `bulkUpload`, `organizeDocument` | Medium |
| **Parsers** | Add support for: Markdown, HTML, URLs, Google Docs | Medium |
| **Frontend** | Add folder sidebar, tag chips, search bar with server-side search | Medium-Large |
| **Frontend** | Add bulk upload UI, URL import dialog | Medium |
| **Frontend** | Add content editing (rich text or markdown) | Large |
| **AI** | Add summarization, auto-tagging, embeddings for semantic search | Large |
| **Queue** | Add background processing for large files, URL imports, AI analysis | Medium |

### Must Change (Breaking or Restructuring)

| Area | Change | Reason | Effort |
|------|--------|--------|--------|
| **Routing** | Rename `/documents` -> `/knowledge-base` or `/kb` | URL branding | Small (but touches many files) |
| **UI header** | Already shows "Knowledge Base" as the page title | Already partially done! | None |
| **Contract** | Consider renaming `documents.*` -> `kb.*` or keep as-is | Naming consistency | Medium if renamed |
| **Content storage** | Add extracted text caching (new column or separate storage key) | Performance: re-parsing on every read is wasteful | Medium |
| **Upload** | Consider multipart form upload instead of base64 | 33% overhead is significant for 10MB files | Medium |
| **List API** | Return pagination metadata in response (total, hasMore) | Currently calculated but not returned to client | Small |
| **Search** | Server-side search (Postgres full-text or external) | Client-side search won't scale | Medium-Large |
| **Referential integrity** | Handle dangling doc IDs in podcasts/infographics on delete | Data consistency | Small-Medium |
| **Shared upload code** | Consolidate the 3 duplicate upload implementations | DRY principle | Small |

### Already Aligned (No Change Needed)

- **Authorization model** -- per-user ownership with `requireOwnership` is correct
- **Effect TS patterns** -- use cases follow Effect best practices
- **Error handling** -- all errors use `Schema.TaggedError` with HTTP protocol
- **Repository pattern** -- clean `Context.Tag` / `Layer` separation
- **Frontend architecture** -- container/presenter split is well-implemented
- **Testing** -- good unit test coverage for use cases
- **Activity logging** -- already integrated for CRUD operations
- **OpenTelemetry tracing** -- all handlers and use cases have spans
